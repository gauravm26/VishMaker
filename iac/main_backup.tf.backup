# ==================================================
# MAIN INFRASTRUCTURE - Orchestrates all AWS services
# ==================================================

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.4"
    }
  }
  backend "s3" {
    bucket         = "vish-terraform"
    key            = "vishmaker/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "vishmaker-terraform-locks"
  }
}

# Configure AWS Provider
provider "aws" {
  region = var.aws_region
}

# Local values - Consolidated configuration objects
locals {
  name_prefix = "${var.environment}-${var.project_name}"
  # ðŸ·ï¸ Common configuration object
  common_config = {
    project_name = var.project_name
    environment  = var.environment
    aws_region   = var.aws_region
    name_prefix  = local.name_prefix
    domain_name  = var.domain_name
    tags = merge(var.common_tags, {
      Name        = local.name_prefix
      Project     = var.project_name
      Environment = var.environment
    })
  }

  # ðŸ·ï¸ Common DynamoDB environment variables
  # Temporarily commented out until all DynamoDB tables are imported
  # common_dynamodb_env_vars = {
  #   PROJECTS_TABLE_NAME                = aws_dynamodb_table.tables["projects"].name,
  #   USER_FLOWS_TABLE_NAME              = aws_dynamodb_table.tables["user-flows"].name,
  #   HIGH_LEVEL_REQUIREMENTS_TABLE_NAME = aws_dynamodb_table.tables["high-level-requirements"].name,
  #   LOW_LEVEL_REQUIREMENTS_TABLE_NAME  = aws_dynamodb_table.tables["low-level-requirements"].name,
  #   TEST_CASES_TABLE_NAME              = aws_dynamodb_table.tables["test-cases"].name
  # }

  # ðŸ·ï¸ Lambda configuration object

}



# ==================================================
# S3 CONFIGURATION BUCKET
# ==================================================

# S3 bucket for configuration files
resource "aws_s3_bucket" "configs" {
  bucket        = "${var.config_bucket_prefix}-${var.environment}-${random_string.bucket_suffix.result}"
  force_destroy = var.s3_force_destroy

  tags = merge(local.common_config.tags, {
    Name = "${local.name_prefix}-config-bucket"
  })
}

resource "random_string" "bucket_suffix" {
  length  = 8
  special = false
  upper   = false
}

resource "aws_s3_bucket_ownership_controls" "configs" {
  bucket = aws_s3_bucket.configs.id

  rule {
    object_ownership = "BucketOwnerPreferred"
  }
}

resource "aws_s3_bucket_public_access_block" "configs" {
  bucket = aws_s3_bucket.configs.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_s3_bucket_server_side_encryption_configuration" "configs" {
  bucket = aws_s3_bucket.configs.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Upload configuration file to S3
resource "aws_s3_object" "app_config" {
  bucket = aws_s3_bucket.configs.id
  key    = "config.json"
  source = "${path.module}/../app/backend/config/config.json"
  etag   = filemd5("${path.module}/../app/backend/config/config.json")
  tags   = local.common_config.tags
}


# ==================================================
# API GATEWAY
# ==================================================

locals {
  api_gateway = {
    name         = "${local.name_prefix}-api"
    cors_origins = ["https://vishmaker.com"]
    tags         = local.common_config.tags
  }
  api_routes = {
    auth_api = {
      routes = [
        {
          path    = ["/auth/signin", "/auth/signup", "/auth/confirm-signup", "/auth/forgot-password", "/auth/confirm-forgot-password"]
          methods = ["POST"]
          auth    = "NONE"
        },
        {
          path    = ["/auth/me", "/auth/signout", "/auth/refresh-token"]
          methods = ["GET", "POST"]
          auth    = "JWT"
        }
      ]
      lambda_arn    = aws_lambda_function.lambda["auth_api"].invoke_arn
      function_name = aws_lambda_function.lambda["auth_api"].function_name
    }
    projects_api = {
      routes = [
        {
          path    = ["/projects", "/projects/{proxy+}"]
          methods = ["GET", "POST", "PUT", "DELETE"]
          auth    = "JWT"
        }
      ]
      lambda_arn    = aws_lambda_function.lambda["projects_api"].invoke_arn
      function_name = aws_lambda_function.lambda["projects_api"].function_name
    }
    requirements_api = {
      routes = [
        {
          path    = ["/requirements", "/requirements/{proxy+}"]
          methods = ["GET", "POST", "PUT", "DELETE"]
          auth    = "JWT"
        }
      ]
      lambda_arn    = aws_lambda_function.lambda["requirements_api"].invoke_arn
      function_name = aws_lambda_function.lambda["requirements_api"].function_name
    }
    llm_api = {
      routes = [
        {
          path    = ["/llm/{proxy+}"]
          methods = ["GET", "POST", "PUT", "DELETE"]
          auth    = "JWT"
        }
      ]
      lambda_arn    = aws_lambda_function.lambda["llm_api"].invoke_arn
      function_name = aws_lambda_function.lambda["llm_api"].function_name
    }
  }
  flattened_routes = {
    for route in flatten([
      for integration_key, api in local.api_routes : [
        for route in api.routes : [
          for path in route.path : [
            for method in route.methods : {
              key = "${integration_key}-${method}-${replace(replace(path, "/", "_"), "{", "_")}"
              value = {
                route_key       = "${method} ${path}"
                integration_key = integration_key
                auth_type       = route.auth
                lambda_arn      = api.lambda_arn
              }
            }
          ]
        ]
      ]
    ]) : route.key => route.value
  }
}

resource "aws_apigatewayv2_api" "main" {
  name          = "${local.name_prefix}-api"
  protocol_type = "HTTP"

  cors_configuration {
    allow_credentials = true
    allow_headers     = ["*"]
    allow_methods     = ["*"]
    allow_origins     = ["https://vishmaker.com"]
    expose_headers    = ["*"]
    max_age           = 86400
  }
  tags = local.common_config.tags
}

# Custom domain for API Gateway (REGIONAL)
resource "aws_apigatewayv2_domain_name" "api" {
  domain_name = "api.vishmaker.com"

  domain_name_configuration {
    certificate_arn = aws_acm_certificate_validation.api.certificate_arn
    endpoint_type   = "REGIONAL"
    security_policy = "TLS_1_2"
  }
}

resource "aws_apigatewayv2_api_mapping" "api" {
  api_id      = aws_apigatewayv2_api.main.id
  domain_name = aws_apigatewayv2_domain_name.api.id
  stage       = aws_apigatewayv2_stage.main.id
}

# API Gateway Stage
resource "aws_apigatewayv2_stage" "main" {
  api_id = aws_apigatewayv2_api.main.id
  name   = "$default"

  auto_deploy = true

  tags = local.common_config.tags
}

resource "aws_apigatewayv2_authorizer" "cognito" {
  api_id           = aws_apigatewayv2_api.main.id
  authorizer_type  = "JWT"
  identity_sources = ["$request.header.Authorization"]
  name             = "${local.common_config.project_name}-${local.common_config.environment}-cognito-authorizer"

  jwt_configuration {
    audience = [local.cognito_user_pool_client_id]
    issuer   = "https://cognito-idp.${local.common_config.aws_region}.amazonaws.com/${local.cognito_user_pool_id}"
  }
}

resource "aws_apigatewayv2_route" "routes" {
  for_each = local.flattened_routes

  api_id             = aws_apigatewayv2_api.main.id
  route_key          = each.value.route_key
  target             = "integrations/${aws_apigatewayv2_integration.api[each.value.integration_key].id}"
  authorization_type = each.value.auth_type
  authorizer_id      = each.value.auth_type == "JWT" ? aws_apigatewayv2_authorizer.cognito.id : null
}


resource "aws_apigatewayv2_integration" "api" {
  for_each = {
    for key, value in local.api_routes :
    key => value.lambda_arn
  }

  api_id                 = aws_apigatewayv2_api.main.id
  integration_type       = "AWS_PROXY"
  integration_uri        = each.value
  payload_format_version = "2.0"
  timeout_milliseconds   = 30000 # 30 seconds (maximum allowed by API Gateway v2)
}

resource "aws_lambda_permission" "apigw_permissions" {
  for_each = {
    for key, val in local.api_routes : key => val.function_name
  }

  statement_id  = "AllowAPIGatewayInvoke_${each.key}"
  action        = "lambda:InvokeFunction"
  function_name = each.value
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_apigatewayv2_api.main.execution_arn}/*/*"
}


# Note: CORS routes are no longer needed since CloudFront will handle routing
# and eliminate cross-origin issues by serving both frontend and API from the same domain

# Health check route
resource "aws_apigatewayv2_route" "health_check" {
  api_id    = aws_apigatewayv2_api.main.id
  route_key = "GET /ping"
  target    = "integrations/${aws_apigatewayv2_integration.api["auth_api"].id}"
}

# Default route for root path
resource "aws_apigatewayv2_route" "root" {
  api_id    = aws_apigatewayv2_api.main.id
  route_key = "GET /"
  target    = "integrations/${aws_apigatewayv2_integration.api["auth_api"].id}"
}

# ==================================================
# CLOUDFRONT
# ==================================================

# CloudFront distribution - will import existing one
resource "aws_cloudfront_distribution" "main" {
  enabled = true

  # S3 Origin for frontend (your existing S3 bucket)
  origin {
    origin_id   = "S3-vishmaker.com"
    domain_name = "vishmaker.com.s3.us-east-1.amazonaws.com"

    custom_origin_config {
      http_port              = 80
      https_port             = 443
      origin_protocol_policy = "match-viewer"
      origin_ssl_protocols   = ["TLSv1.2"]
    }
  }

  # ALB Origin for WebSocket and health checks (your existing ALB)
  origin {
    origin_id   = "ALB-API-Backend"
    domain_name = "dev-vishkits-webhosting-api-alb-231976377.us-east-1.elb.amazonaws.com"
    custom_origin_config {
      http_port              = 80
      https_port             = 443
      origin_protocol_policy = "match-viewer"
      origin_ssl_protocols   = ["TLSv1.2"]
    }
  }

  # API Gateway Origin for backend APIs (your existing)
  origin {
    origin_id   = "APIGATEWAY-API-Backend"
    domain_name = aws_apigatewayv2_domain_name.api.domain_name
    custom_origin_config {
      http_port              = 80
      https_port             = 443
      origin_protocol_policy = "https-only"
      origin_ssl_protocols   = ["TLSv1.2"]
    }
  }

  # Minimal default cache behavior (required by Terraform)
  default_cache_behavior {
    allowed_methods        = ["GET", "HEAD"]
    cached_methods         = ["GET", "HEAD"]
    target_origin_id       = "S3-vishmaker.com" # Reference your existing S3 origin
    viewer_protocol_policy = "redirect-to-https"
    cache_policy_id          = data.aws_cloudfront_cache_policy.Managed_Optimized.id
  }

  # WebSocket Cache Behavior (your existing)
  ordered_cache_behavior {
    path_pattern           = "/ws*"
    target_origin_id       = "ALB-API-Backend"
    viewer_protocol_policy = "redirect-to-https"
    allowed_methods        = ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"]
    cached_methods         = ["GET", "HEAD"] 
    cache_policy_id          = data.aws_cloudfront_cache_policy.Managed-CachingDisabled.id
    origin_request_policy_id = data.aws_cloudfront_origin_request_policy.Managed-AllViewer.id
  }

  # Health Check Cache Behavior (your existing)
  ordered_cache_behavior {
    path_pattern           = "/health"
    target_origin_id       = "ALB-API-Backend"
    viewer_protocol_policy = "redirect-to-https"
    allowed_methods        = ["GET", "HEAD", "OPTIONS"]
    cached_methods         = ["GET", "HEAD"]
    cache_policy_id          = data.aws_cloudfront_cache_policy.Managed-CachingDisabled.id
    origin_request_policy_id = data.aws_cloudfront_origin_request_policy.Managed-AllViewer.id
  }

  # Note: Terraform will now manage all cache behaviors

  # API Cache Behavior for backend APIs
  ordered_cache_behavior {
    path_pattern           = "/api/*"
    target_origin_id       = "APIGATEWAY-API-Backend"
    viewer_protocol_policy = "redirect-to-https"
    allowed_methods        = ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"]
    cached_methods         = ["GET", "HEAD"]
    cache_policy_id          = data.aws_cloudfront_cache_policy.Managed-CachingDisabled.id
    origin_request_policy_id = data.aws_cloudfront_origin_request_policy.Managed-AllViewer.id
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }
}

# Data source for existing CloudFront distribution
data "aws_cloudfront_distribution" "existing" {
  id = var.cloudfront_distribution_id
}

# Note: Using existing OAC "dev-vishkits-webhosting-s3-oac" instead of creating new OAI

# Data source to get the S3 bucket from the CloudFront distribution's origin
data "aws_s3_bucket" "existing" {
  bucket = var.domain_name
}



# Locals for easy reference to the existing resources
locals {
  cloudfront_distribution = data.aws_cloudfront_distribution.existing
  s3_bucket               = data.aws_s3_bucket.existing
  hosted_zone             = data.aws_route53_zone.existing
}

data "aws_cloudfront_cache_policy" "Managed_Optimized" {
  name = "Managed-CachingOptimized"
}

data "aws_cloudfront_cache_policy" "Managed-CachingDisabled" {
  name = "Managed-CachingDisabled"
}

data "aws_cloudfront_origin_request_policy" "Managed-AllViewer" {
  name = "Managed-AllViewer"
}

# Note: We're not creating a new CloudFront distribution
# Instead, we'll add the API Gateway origin to your existing CloudFront
# You'll need to manually add this origin and cache behavior to your existing CloudFront distribution




# ==================================================
# ROUTE53
# ==================================================

# Data source for the hosted zone
data "aws_route53_zone" "main" {
  name = var.domain_name
}

# Data source to find existing hosted zone by domain name
data "aws_route53_zone" "existing" {
  name = var.domain_name
}

resource "aws_acm_certificate" "api" {
  domain_name       = "api.vishmaker.com"
  validation_method = "DNS"
}

resource "aws_route53_record" "api_cert_validation" {
  for_each = {
    for dvo in aws_acm_certificate.api.domain_validation_options :
    dvo.domain_name => {
      name   = dvo.resource_record_name
      type   = dvo.resource_record_type
      record = dvo.resource_record_value
    }
  }

  zone_id = data.aws_route53_zone.existing.zone_id
  name    = each.value.name
  type    = each.value.type
  ttl     = 60
  records = [each.value.record]
}

resource "aws_acm_certificate_validation" "api" {
  certificate_arn         = aws_acm_certificate.api.arn
  validation_record_fqdns = [for r in aws_route53_record.api_cert_validation : r.fqdn]
}


# ==================================================
# COGNITO
# ==================================================

# Cognito User Pool
/* resource "aws_cognito_user_pool" "main" {
  name = "${local.common_config.name_prefix}-user-pool"

  # Password policy
  password_policy {
    minimum_length    = 8
    require_lowercase = true
    require_numbers   = true
    require_symbols   = true
    require_uppercase = true
  }

  # User attributes
  alias_attributes         = ["email"]
  auto_verified_attributes = ["email"]
  
  # Email verification
  verification_message_template {
    default_email_option = "CONFIRM_WITH_CODE"
    email_subject        = "Your VishMaker verification code"
    email_message        = "Your verification code is {####}. Welcome to VishMaker!"
  }

  # Account recovery
  account_recovery_setting {
    recovery_mechanism {
      name     = "verified_email"
      priority = 1
    }
  }

  # MFA configuration
  mfa_configuration = "OFF"

  # Admin create user configuration
  admin_create_user_config {
    allow_admin_create_user_only = false
    
    invite_message_template {
      email_subject = "Your VishMaker account"
      email_message = "Welcome to VishMaker! Your username is {username} and temporary password is {####}"
      sms_message   = "Your VishMaker username is {username} and temporary password is {####}"
    }
  }

  # User pool add-ons
  user_pool_add_ons {
    advanced_security_mode = "OFF"
  }

  tags = local.common_config.tags

  lifecycle {
    prevent_destroy = true  # ðŸ”’ Protect existing users and prevent accidental deletion
  }
} */

locals {
  cognito_user_pool_id        = "us-east-1_Hf4Ps4b4j"
  cognito_user_pool_arn       = "arn:aws:cognito-idp:us-east-1:489270312286:userpool/us-east-1_Hf4Ps4b4j"
  cognito_user_pool_client_id = "6vtj80n9u3916hnlpnpbi7r2v9"

}

# Cognito User Pool Client
/* resource "aws_cognito_user_pool_client" "main" {
  name         = "${local.common_config.name_prefix}-user-pool-client"
  user_pool_id = local.user_pool_id

  # Client settings
  generate_secret                      = false
  prevent_user_existence_errors       = "ENABLED"
  enable_token_revocation             = true
  enable_propagate_additional_user_context_data = false

  # Auth flows
  explicit_auth_flows = [
    "ALLOW_USER_PASSWORD_AUTH",
    "ALLOW_USER_SRP_AUTH",
    "ALLOW_REFRESH_TOKEN_AUTH"
  ]

  # Token validity
  access_token_validity  = 60    # 1 hour
  id_token_validity      = 60    # 1 hour
  refresh_token_validity = 30    # 30 days

  token_validity_units {
    access_token  = "minutes"
    id_token      = "minutes"
    refresh_token = "days"
  }

  # Read/write attributes
  read_attributes = [
    "email",
    "email_verified",
    "preferred_username"
  ]

  write_attributes = [
    "email",
    "preferred_username"
  ]

  #lifecycle {
  #  prevent_destroy = true  # ðŸ”’ Protect existing client configuration and prevent accidental deletion
  #}
} */

# Cognito User Pool Domain
/* 
resource "aws_cognito_user_pool_domain" "main" {
  domain       = "auth-vishmaker"
  user_pool_id = local.cognito_user_pool_id

/*   lifecycle {
    prevent_destroy = true  # ðŸ”’ Protect existing domain configuration and prevent accidental deletion
  } */




# ==================================================
# LAMBDAS
# ==================================================
locals {
  lambda_config = {
    timeout            = 60
    memory_size        = 512
    architectures      = ["x86_64"]
    layers             = []
    runtime            = "python3.11"
    common_tags        = var.common_tags
    handler            = "main.handler"
    root_path          = "${path.module}/../scripts/dist"
    log_retention_days = 1
  }
  lambdas = {
    auth_api = {
      lambda_name = "auth"
      environment_variables = {
        COGNITO_USER_POOL_ID = local.cognito_user_pool_id
        COGNITO_CLIENT_ID    = local.cognito_user_pool_client_id
      }
      dynamo_access_all = false
      timeout           = 60
      memory_size       = 512
    },
    llm_api = {
      lambda_name = "llm"
      environment_variables = merge(
        # local.common_dynamodb_env_vars,
        {
          CONFIG_BUCKET = aws_s3_bucket.configs.id
          CONFIG_KEY    = "config.json"
          ENVIRONMENT   = var.environment
          PROJECT_NAME  = var.project_name
        }
      )
      dynamo_access_all = true
      timeout           = var.lambda_timeout_seconds
      memory_size       = var.lambda_memory_mb
    },
    projects_api = {
      lambda_name           = "projects"
      environment_variables = {} # local.common_dynamodb_env_vars
      dynamo_access_all     = true
    },
    requirements_api = {
      lambda_name           = "requirements"
      environment_variables = {} # local.common_dynamodb_env_vars
      dynamo_access_all     = true
    }
  }
  all_dynamo_tables_arns = [
    for table in aws_dynamodb_table.tables : table.arn
  ]
  lambda_arns_by_key = {
    for k, lambda in aws_lambda_function.lambda :
    k => lambda.invoke_arn
  }
  lambda_arns_by_function_name = {
    for k, lambda in aws_lambda_function.lambda :
    lambda.function_name => lambda.arn
  }
}


resource "aws_lambda_function" "lambda" {
  for_each = local.lambdas

  function_name    = "${local.name_prefix}-${each.value.lambda_name}"
  role             = aws_iam_role.lambda_role[each.key].arn
  filename         = "${local.lambda_config.root_path}/${each.value.lambda_name}-deployment.zip"
  handler          = try(each.value.handler, local.lambda_config.handler)
  runtime          = try(each.value.runtime, local.lambda_config.runtime)
  source_code_hash = filebase64sha256("${local.lambda_config.root_path}/${each.value.lambda_name}-deployment.zip")
  timeout          = try(each.value.timeout, local.lambda_config.timeout)
  memory_size      = try(each.value.memory_size, local.lambda_config.memory_size)
  architectures    = try(each.value.architectures, local.lambda_config.architectures)
  layers           = try(each.value.layers, local.lambda_config.layers)
  tags             = try(each.value.tags, local.lambda_config.common_tags)

  environment {
    variables = each.value.environment_variables
  }
}

resource "aws_iam_role" "lambda_role" {
  for_each = local.lambdas

  name = "${var.environment}-${var.project_name}-${each.value.lambda_name}-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Action = "sts:AssumeRole",
      Effect = "Allow",
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })

  tags = local.lambda_config.common_tags
}

resource "aws_iam_role_policy_attachment" "basic_execution" {
  for_each = local.lambdas

  role       = aws_iam_role.lambda_role[each.key].name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}


resource "aws_cloudwatch_log_group" "lambda_logs" {
  for_each          = local.lambdas
  name              = "/aws/lambda/${var.environment}-${var.project_name}-${each.value.lambda_name}"
  retention_in_days = local.lambda_config.log_retention_days
  tags              = local.lambda_config.common_tags
}

resource "aws_iam_role_policy_attachment" "attach_dynamo_policy_lambda" {
  for_each = {
    for k, v in local.lambdas :
    k => v if try(v.dynamo_access_all, false)
  }

  role       = aws_iam_role.lambda_role[each.key].name
  policy_arn = aws_iam_policy.dynamodb_rw_policy.arn
}

# Cognito IAM policy for auth Lambda
resource "aws_iam_role_policy" "auth_lambda_cognito_policy" {
  name = "${var.environment}-${var.project_name}-auth-cognito-policy"
  role = aws_iam_role.lambda_role["auth_api"].id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "cognito-idp:AdminInitiateAuth",
          "cognito-idp:AdminCreateUser",
          "cognito-idp:AdminConfirmSignUp",
          "cognito-idp:AdminSetUserPassword",
          "cognito-idp:AdminUpdateUserAttributes",
          "cognito-idp:AdminGetUser",
          "cognito-idp:ListUsers",
          "cognito-idp:AdminDeleteUser",
          "cognito-idp:AdminResetUserPassword",
          "cognito-idp:AdminRespondToAuthChallenge",
          "cognito-idp:ForgotPassword",
          "cognito-idp:ConfirmForgotPassword",
          "cognito-idp:RespondToAuthChallenge",
          "cognito-idp:InitiateAuth",
          "cognito-idp:SignUp",
          "cognito-idp:ConfirmSignUp",
          "cognito-idp:ResendConfirmationCode",
          "cognito-idp:GlobalSignOut",
          "cognito-idp:GetUser"
        ]
        Resource = local.cognito_user_pool_arn
      }
    ]
  })
}

# S3 IAM policy for LLM Lambda
resource "aws_iam_role_policy" "llm_lambda_s3_policy" {
  name = "${var.environment}-${var.project_name}-llm-s3-policy"
  role = aws_iam_role.lambda_role["llm_api"].id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:GetObjectVersion"
        ]
        Resource = "${aws_s3_bucket.configs.arn}/*"
      }
    ]
  })
}

# Bedrock IAM policy for LLM Lambda
resource "aws_iam_role_policy" "llm_lambda_bedrock_policy" {
  name = "${var.environment}-${var.project_name}-llm-bedrock-policy"
  role = aws_iam_role.lambda_role["llm_api"].id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "bedrock:InvokeModel",
          "bedrock:InvokeModelWithResponseStream",
          "bedrock:GetFoundationModel",
          "bedrock:ListFoundationModels"
        ]
        Resource = "*"
      }
    ]
  })
}


# ==================================================
# DYNAMODB
# ==================================================

locals {
  dynamodb_common = {
    billing_mode = "PAY_PER_REQUEST"
    common_tags  = var.common_tags
  }
  dynamodb_tables = {
    projects = {
      hash_key  = "id"
      range_key = "user_id"
      attributes = [
        { name = "id", type = "S" },
        { name = "user_id", type = "S" },
        { name = "name", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "user_id-index"
          hash_key        = "user_id"
          projection_type = "ALL"
        },
        {
          name            = "name-index"
          hash_key        = "name"
          projection_type = "ALL"
        }
      ]
    }
    "user-flows" = {
      hash_key  = "uiid"
      range_key = "project_id"
      attributes = [
        { name = "uiid", type = "S" },
        { name = "project_id", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "project_id-index"
          hash_key        = "project_id"
          projection_type = "ALL"
        }
      ]
    }

    "high-level-requirements" = {
      hash_key  = "uiid"
      range_key = "parent_uiid"
      attributes = [
        { name = "uiid", type = "S" },
        { name = "project_id", type = "S" },
        { name = "parent_uiid", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "project_id-index"
          hash_key        = "project_id"
          projection_type = "ALL"
        }
      ]
    }

    "low-level-requirements" = {
      hash_key  = "uiid"
      range_key = "parent_uiid"
      attributes = [
        { name = "uiid", type = "S" },
        { name = "project_id", type = "S" },
        { name = "parent_uiid", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "project_id-index"
          hash_key        = "project_id"
          projection_type = "ALL"
        }
      ]
    }

    "test-cases" = {
      hash_key  = "uiid"
      range_key = "parent_uiid"
      attributes = [
        { name = "uiid", type = "S" },
        { name = "project_id", type = "S" },
        { name = "parent_uiid", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "project_id-index"
          hash_key        = "project_id"
          projection_type = "ALL"
        }
      ]
    }
    waitlist = {
      hash_key = "email"
      attributes = [
        { name = "email", type = "S" },
        { name = "status", type = "S" }
      ]
      global_secondary_indexes = [
        {
          name            = "status-index"
          hash_key        = "status"
          projection_type = "ALL"
        }
      ]
    }
  }
  all_dynamodb_table_arns = [
    for table in aws_dynamodb_table.tables :
    table.arn
  ]
  all_dynamodb_index_arns = [
    for table in aws_dynamodb_table.tables :
    "${table.arn}/index/*"
  ]
}

resource "aws_dynamodb_table" "tables" {
  for_each = local.dynamodb_tables

  name         = "${var.environment}-${var.project_name}-${each.key}"
  billing_mode = local.dynamodb_common.billing_mode
  hash_key     = each.value.hash_key
  range_key    = try(each.value.range_key, null)

  dynamic "attribute" {
    for_each = each.value.attributes
    content {
      name = attribute.value.name
      type = attribute.value.type
    }
  }

  dynamic "global_secondary_index" {
    for_each = try(each.value.global_secondary_indexes, [])
    content {
      name            = global_secondary_index.value.name
      hash_key        = global_secondary_index.value.hash_key
      projection_type = global_secondary_index.value.projection_type
    }
  }

  tags = local.common_config.tags
}

resource "aws_iam_policy" "dynamodb_rw_policy" {
  name = "${local.name_prefix}-dynamodb-access-policy"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect = "Allow",
        Action = [
          "dynamodb:PutItem",
          "dynamodb:GetItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Query",
          "dynamodb:Scan"
        ],
        Resource = concat(
          local.all_dynamodb_table_arns,
          local.all_dynamodb_index_arns
        )
      }
    ]
  })
}





provider "aws" {
  # This provider block is for the main resources (S3, CloudFront, etc.)
  # It will use the region configured in your AWS CLI or environment.
  region = var.aws_region
}

# ACM certificates must be created in us-east-1 for CloudFront
provider "aws" {
  alias  = "acm_provider"
  region = var.aws_region
}

# --- Locals for consistent naming ---
locals {
  name_prefix = "${var.development_environment}-${var.project_name}"
  common_tags = merge(var.tags, {
    Name        = local.name_prefix
    Environment = var.development_environment
    Project     = var.project_name
  })
}

# --- Data Sources for VPC and Subnets ---
data "aws_vpc" "default" {
  default = true
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# --- DNS & Certificate ---
data "aws_route53_zone" "main" {
  name = var.domain_name
}

resource "aws_acm_certificate" "main" {
  provider          = aws.acm_provider
  domain_name       = var.domain_name
  subject_alternative_names = ["www.${var.domain_name}"]
  validation_method = "DNS"
  tags              = merge(local.common_tags, {
    Name = "${local.name_prefix}-certificate"
  })

  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_route53_record" "cert_validation" {
  for_each = {
    for dvo in aws_acm_certificate.main.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }
  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.main.zone_id
}

resource "aws_acm_certificate_validation" "main" {
  provider        = aws.acm_provider
  certificate_arn = aws_acm_certificate.main.arn
  validation_record_fqdns = [for record in aws_route53_record.cert_validation : record.fqdn]
}

# --- S3 & CloudFront Hosting ---
resource "aws_s3_bucket" "main" {
  count  = var.deployment_type == "migrate" ? 1 : 0
  bucket = var.domain_name
  tags   = merge(local.common_tags, {
    Name = "${local.name_prefix}-website-bucket"
  })
}

resource "aws_cloudfront_origin_access_control" "main" {
  name                              = "${local.name_prefix}-s3-oac"
  origin_access_control_origin_type = "s3"
  signing_behavior                  = "always"
  signing_protocol                  = "sigv4"
  
  lifecycle {
    create_before_destroy = true
  }
}

# CloudFront Function for SPA routing
resource "aws_cloudfront_function" "rewrite_spa_routes" {
  name    = "${local.name_prefix}-rewrite-spa-routes"
  runtime = "cloudfront-js-1.0"
  comment = "Rewrites all unknown paths to index.html for SPA routing"

  publish = true

  code = <<EOT
function handler(event) {
  var request = event.request;
  var uri = request.uri;

  if (!uri.includes('.') && !uri.endsWith('/')) {
    request.uri = '/index.html';
  }

  return request;
}
EOT
}

resource "aws_s3_bucket_policy" "main" {
  count  = var.deployment_type == "migrate" ? 1 : 0
  bucket = aws_s3_bucket.main[0].id
  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Effect    = "Allow",
      Principal = { Service = "cloudfront.amazonaws.com" },
      Action    = "s3:GetObject",
      Resource  = "${aws_s3_bucket.main[0].arn}/*",
      Condition = { StringEquals = { "AWS:SourceArn" = aws_cloudfront_distribution.main.arn } }
    }]
  })
}

# --- Application Load Balancer for API/WebSocket ---
resource "aws_security_group" "alb_sg" {
  name        = "${local.name_prefix}-alb-sg"
  description = "Allow HTTPS traffic to ALB"
  vpc_id      = data.aws_vpc.default.id
  tags        = merge(local.common_tags, { Name = "${local.name_prefix}-alb-sg" })

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_lb" "api_alb" {
  name               = "${local.name_prefix}-api-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb_sg.id]
  subnets            = data.aws_subnets.default.ids
  tags               = merge(local.common_tags, { Name = "${local.name_prefix}-api-alb" })
}

resource "aws_lb_target_group" "api_tg" {
  name        = "${local.name_prefix}-api-tg"
  port        = 8000 # Port the Docker container listens on
  protocol    = "HTTP"
  vpc_id      = data.aws_vpc.default.id
  target_type = "instance"
  tags        = merge(local.common_tags, { Name = "${local.name_prefix}-api-tg" })

  health_check {
    path                = "/" # FastAPI responds to this by default
    protocol            = "HTTP"
    matcher             = "200"
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 5
    interval            = 30
  }
}

resource "aws_lb_listener" "api_listener" {
  load_balancer_arn = aws_lb.api_alb.arn
  port              = "80"
  protocol          = "HTTP"

  # The default action is to forward to our EC2 target group.
  # Note: The listener is HTTP because CloudFront handles the HTTPS termination.
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.api_tg.arn
  }
}

resource "aws_lb_target_group_attachment" "api_attachment" {
  target_group_arn = aws_lb_target_group.api_tg.arn
  target_id        = "i-0bfbb3ab79c2f1c78" # Your EC2 instance ID
  port             = 8000
}

resource "aws_cloudfront_distribution" "main" {
  # Origin for S3 hosting (migrate deployment)
  dynamic "origin" {
    for_each = var.deployment_type == "migrate" ? [1] : []
    content {
      domain_name              = aws_s3_bucket.main[0].bucket_regional_domain_name
      origin_id                = "S3-${var.domain_name}"
      origin_access_control_id = aws_cloudfront_origin_access_control.main.id
    }
  }

  # ALB origin for API/WebSocket connections
  dynamic "origin" {
    for_each = [1] # Always create ALB origin
    content {
      domain_name = aws_lb.api_alb.dns_name
      origin_id   = "ALB-API-Backend"

      custom_origin_config {
        # CloudFront will talk to the ALB over standard HTTP.
        # The connection from User -> CloudFront is what's encrypted.
        http_port              = 80
        https_port             = 443
        origin_protocol_policy = "http-only"
        origin_ssl_protocols   = ["TLSv1.2"]
      }
    }
  }

  ordered_cache_behavior {
    path_pattern     = "/ws*" # Catches /ws and /ws/logs
    target_origin_id = "ALB-API-Backend"

    allowed_methods = ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"]
    cached_methods  = ["GET", "HEAD", "OPTIONS"]

    # These policies are CRITICAL for WebSockets and APIs to work correctly.
    # It forwards all headers and query strings and disables caching.
    cache_policy_id          = "4135ea2d-6df8-44a3-9df3-4b5a84be39ad" # Managed-CachingDisabled
    origin_request_policy_id = "216adef6-5c7f-47e4-b989-5492eafa07d3"
     # Managed-AllViewer

    viewer_protocol_policy = "redirect-to-https"
    compress               = true
  }

  ordered_cache_behavior {
  path_pattern     = "/health"
  target_origin_id = "ALB-API-Backend" # Same origin as your WebSocket

  allowed_methods = ["GET", "HEAD", "OPTIONS"]
  cached_methods  = ["GET", "HEAD"]

  # Use the same policies to disable caching and forward headers.
  cache_policy_id          = "4135ea2d-6df8-44a3-9df3-4b5a84be39ad" # Managed-CachingDisabled
  origin_request_policy_id = "216adef6-5c7f-47e4-b989-5492eafa07d3" # Managed-AllViewer

  viewer_protocol_policy = "redirect-to-https"
  compress               = true
 }


  enabled             = true
  is_ipv6_enabled     = true
  default_root_object = "index.html"
  aliases             = [var.domain_name, "www.${var.domain_name}"]

  default_cache_behavior {
    allowed_methods  = ["GET", "HEAD", "OPTIONS"]
    cached_methods   = ["GET", "HEAD", "OPTIONS"]
    target_origin_id = var.deployment_type == "migrate" ? "S3-${var.domain_name}" : "placeholder-${var.domain_name}"
    viewer_protocol_policy = "redirect-to-https"
    compress               = true

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }

    min_ttl     = 0
    default_ttl = 3600
    max_ttl     = 86400

    function_association {
      event_type   = "viewer-request"
      function_arn = aws_cloudfront_function.rewrite_spa_routes.arn
    }
  }

  custom_error_response {
    error_code            = 404
    response_code         = 200
    response_page_path    = "/index.html"
    error_caching_min_ttl = 0
  }

  custom_error_response {
    error_code            = 403
    response_code         = 200
    response_page_path    = "/index.html"
    error_caching_min_ttl = 0
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    acm_certificate_arn = aws_acm_certificate_validation.main.certificate_arn
    ssl_support_method  = "sni-only"
  }
  tags = merge(local.common_tags, {
    Name = "${local.name_prefix}-cloudfront-distribution"
  })
}

# --- Final DNS Records ---
resource "aws_route53_record" "root" {
  zone_id = data.aws_route53_zone.main.zone_id
  name    = var.domain_name
  type    = "A"
  alias {
    name                   = aws_cloudfront_distribution.main.domain_name
    zone_id                = aws_cloudfront_distribution.main.hosted_zone_id
    evaluate_target_health = false
  }
}

resource "aws_route53_record" "www" {
  zone_id = data.aws_route53_zone.main.zone_id
  name    = "www.${var.domain_name}"
  type    = "A"
  alias {
    name                   = aws_cloudfront_distribution.main.domain_name
    zone_id                = aws_cloudfront_distribution.main.hosted_zone_id
    evaluate_target_health = false
  }
}

# --- Outputs ---
output "domain_name" {
  description = "The domain name being hosted"
  value       = var.domain_name
}

output "cloudfront_distribution_id" {
  description = "The ID of the CloudFront distribution"
  value       = aws_cloudfront_distribution.main.id
}

output "cloudfront_domain_name" {
  description = "The domain name of the CloudFront distribution"
  value       = aws_cloudfront_distribution.main.domain_name
}

output "s3_bucket_name" {
  description = "The name of the S3 bucket hosting the website"
  value       = length(aws_s3_bucket.main) > 0 ? aws_s3_bucket.main[0].bucket : null
}

output "website_url" {
  description = "The URL of the hosted website"
  value       = "https://${var.domain_name}"
}

output "aws_region" {
  description = "The AWS region where resources are deployed"
  value       = var.aws_region
}

output "resource_prefix" {
  description = "The resource naming prefix used"
  value       = local.name_prefix
}

output "alb_dns_name" {
  description = "The DNS name of the Application Load Balancer"
  value       = aws_lb.api_alb.dns_name
}

output "alb_security_group_id" {
  description = "The ID of the security group attached to the ALB."
  value       = aws_security_group.alb_sg.id
}